function Get-NotebookContent {
    <#
        .SYNOPSIS
        Get-NotebookContents reads the contents of a Jupyter Notebooks

        .Example
        Get-NotebookContent .\samplenotebook\Chapter01code.ipynb

NoteBookName        Type     Source
------------        ----     ------
Chapter01code.ipynb markdown ## Code for chapter 1 PowerShell in Action third edition
Chapter01code.ipynb markdown ## Introduction
Chapter01code.ipynb code     'Hello world.'
Chapter01code.ipynb code     Get-ChildItem -Path $env:windir\*.log | Select-String -List error | Format-Table Path,L...
Chapter01code.ipynb code     ([xml] [System.Net.WebClient]::new().DownloadString('http://blogs.msdn.com/powershell/r...
Chapter01code.ipynb markdown ## 1.2 PowerShell example code
Chapter01code.ipynb code     Get-ChildItem -Path C:\somefile.txt

        .Example
        Get-Notebook .\samplenotebook\*sharp*|Get-NotebookContent

NoteBookName Type Source
------------ ---- ------
csharp.ipynb code {Console.Write("hello world")}
fsharp.ipynb code {printfn "hello world"}

    #>
    [cmdletbinding(DefaultParameterSetName="MarkdownAndCode")]
    param(
        [Parameter(ValueFromPipelineByPropertyName,Position=0)]
        [alias('FullName')]
        $NoteBookFullName,
        [parameter(ParameterSetName='JustCode')]
        [alias('NoMarkdown')]
        [Switch]$JustCode,
        [parameter(ParameterSetName='JustMarkdown')]
        [alias('NoCode')]
        [Switch]$JustMarkdown,
        [Switch]$PassThru,
        [Switch]$Includeoutput
    )

    Process {

        if ([System.Uri]::IsWellFormedUriString($NoteBookFullName, [System.UriKind]::Absolute)) {
            $r = Invoke-RestMethod $NoteBookFullName
        }
        elseif (Test-Path $NoteBookFullName -ErrorAction SilentlyContinue) {
            if ((Resolve-Path $NoteBookFullName).count -gt 1) {
                [void]$PSBoundParameters.Remove('NotebookFullname')
                Get-ChildItem $NoteBookFullName | Get-NotebookContent @PSBoundParameters
                return
            }
            else {
                $r = Get-Content  $NoteBookFullName | ConvertFrom-Json
            }
        }

        if($PassThru) {
            return $r
        }
        elseif ($JustCode)     { $cellType = "code"     }
        elseif ($JustMarkdown) { $cellType = "markdown" }
        else                   { $cellType = "."         }

        $r.cells | Where-Object { $_.cell_type -match $cellType } | ForEach-Object {
            $cell = [Ordered]@{
                NoteBookName = Split-Path -Leaf $NoteBookFullName
                Type         = $_.'cell_type'
                Source       = -join $_.source
            }
            if ($Includeoutput) {
                # There may be one or many outputs. For each  output either
                # a single string if has a .text field containing a string or array of strings
                # A hash table if it has a .data field containing .mime-type = "Content"
                $cell['Output'] = foreach ($o in $_.outputs) {
                    if     ($o.text -join "") {-join $o.text }
                    elseif ($o.data)          {
                        @{$o.data.psobject.properties.name = $o.data.psobject.properties.value}
                    }
                }
                #merge the text generated by .NET Interactive in VS code - every output will be a hash table with a text/plain entry
                if (    $cell.Output.where({$_ -is    [hashtable]}) -and -not  #Some are hashtables and none are not hashtables
                        $cell.Output.where({$_ -isnot [hashtable]}) ){
                    if ($cell.Output.where({ $_.containskey("text/plain")}) -and -not #some are text/plain and none are not.
                        $cell.Output.where({-not $_.containskey("text/plain")}) ) {
                            $cell.Output = -join $cell.output."text/plain"
                    }
                }
            }
            [PSCustomObject]$cell
        }
    }
}
